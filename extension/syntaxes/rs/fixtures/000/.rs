// a
/// a
//! a

/* a */
/** a */
/*! a */

br#"a"#
b'a'
'a
"{a:?}"

a!();
!a;
a != b;
a % b;
a %= b;
&a;
&u8;
a & b;
a &= b;
a && b;
a * b;
a *= b;
*a;
a + b;
a += b;
a, b;
-a;
a - b;
a -= b;
a -> b;
a.b;
..a;
a..b;
a..;
..=a;
...a;
a / b;
a /= b;
a: b;
'a: loop {}
[a; 8];
a << 8;
a <<= 8;
a = b;
a == b;
a => b;
a > b;
a >= b;
a >> b;
a >>= b;
a @ b;
a ^ b;
a ^= b;
a | b;
a |= b;
a || b;
a?;
0u8;
0.0f32;
a().b();
a::<b as D<A>>;
a: ?Sized;
#![a(b)]
#!["s"]
$ident:kind;
$($a:b),*;
*const u8;
&mut u8;
'static;
let Ok(s) = a;

as u8;
async {}
a.await;
break;
const {}
continue;
crate a;
dyn Any;
else {}
enum A {}
extern "C" {}
false;
fn () -> !;
for a in b {}
if {}
impl<T> A<T> where T: Any {}
let ref mut a;
loop {}
match a {}
pub(super) mod a;
move |_|();
return;
Self;
self;
static A: u8 = 0;
struct A {}
super::A;
trait A {}
true;
type A = B;
union A {}
unsafe {}
use a;
while {} {}

abstract
become
box
do
final
macro
override
priv
try
typeof
unsized
virtual
yield

i8
i16
i32
i64
i128
isize
u8
u16
u32
u64
u128
usize
f32
f64
str
char
bool
